<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>1132936-HW10</title>
    <style>
        body { 
            background-color: #f4f4f4; 
            display: flex; flex-direction: column; align-items: center; 
            font-family: "PingFang TC", "Microsoft JhengHei", sans-serif; 
        }
        .info { 
            text-align: center; margin: 20px; padding: 15px; 
            background: white; border-radius: 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 400px; 
        }
        .board {
            display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px);
            gap: 4px; background-color: #0e3d11; padding: 12px; border-radius: 8px;
            perspective: 1200px; /* 強化 3D 透視感 */
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
        }
        .cell {
            width: 60px; height: 60px; background-color: #2e7d32;
            display: flex; justify-content: center; align-items: center;
            position: relative; cursor: pointer; transition: background 0.2s;
        }
        .cell:hover { background-color: #388e3c; }

        /* 3D 棋子結構 */
        .piece {
            width: 54px; height: 54px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 旋轉定義：黑面朝前為 0deg, 白面朝前為 180deg */
        .piece.black { transform: rotateY(0deg); }
        .piece.white { transform: rotateY(180deg); }

        .side {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%; backface-visibility: hidden;
            box-shadow: inset -3px -3px 8px rgba(0,0,0,0.3), 0 4px 8px rgba(0,0,0,0.4);
        }
        .front { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .back { 
            background: radial-gradient(circle at 30% 30%, #fff, #ccc); 
            transform: rotateY(180deg); 
        }

        .hint { width: 12px; height: 12px; background: rgba(255,255,255,0.2); border-radius: 50%; }
        .controls { margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px; }
        button { padding: 8px 20px; cursor: pointer; background: #1b5e20; color: white; border: none; border-radius: 5px; font-weight: bold; }
        select { padding: 6px; border-radius: 4px; }
    </style>
</head>
<body>

<div class="info">
    <h2>學號：1132936-HW10</h2>
    <div id="status">輪到：黑棋 (玩家)</div>
    <div id="score" style="font-size: 1.2em; margin: 10px 0; font-weight: bold;">黑: 2 | 白: 2</div>
    
    <div class="controls">
        AI 模式: 
        <select id="level">
            <option value="1">基本 (數量優先)</option>
            <option value="2">進階 (權重優先)</option>
        </select>
        <button onclick="initGame()">重新開局</button>
    </div>
</div>

<div id="board" class="board"></div>

<script>
let grid = Array(8).fill().map(() => Array(8).fill(0));
let turn = 1; 
let isAnimating = false;

function createBoardDOM() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${r}-${c}`;
            cell.onclick = () => handlePlayerMove(r, c);
            boardEl.appendChild(cell);
        }
    }
}

function initGame() {
    grid = Array(8).fill().map(() => Array(8).fill(0));
    isAnimating = false;
    turn = 1;
    document.querySelectorAll('.cell').forEach(c => c.innerHTML = '');
    
    // 初始化四子 (不套用翻轉動畫)
    placeStaticPiece(3, 3, 2); placeStaticPiece(3, 4, 1);
    placeStaticPiece(4, 3, 1); placeStaticPiece(4, 4, 2);
    
    updateDisplay();
}

// 靜態放置（用於初始化，不觸發旋轉）
function placeStaticPiece(r, c, color) {
    grid[r][c] = color;
    const cell = document.getElementById(`cell-${r}-${c}`);
    cell.innerHTML = `<div class="piece ${color === 1 ? 'black' : 'white'}"><div class="side front"></div><div class="side back"></div></div>`;
}

// 動態放置/翻轉（執行 3D 動畫）
async function animateFlip(r, c, newColor) {
    const cell = document.getElementById(`cell-${r}-${c}`);
    let piece = cell.querySelector('.piece');
    
    if (!piece) {
        // 如果是剛下的那一子，先產生棋子（隱藏），再顯示
        cell.innerHTML = `<div class="piece ${newColor === 1 ? 'black' : 'white'}"><div class="side front"></div><div class="side back"></div></div>`;
    } else {
        // 如果是現有棋子被翻轉
        piece.className = `piece ${newColor === 1 ? 'black' : 'white'}`;
    }
    grid[r][c] = newColor;
}

function updateDisplay() {
    let b = 0, w = 0;
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            const hint = cell.querySelector('.hint');
            if (grid[r][c] === 0) {
                if (getFlips(r, c, turn).length > 0) {
                    if (!hint) cell.innerHTML = '<div class="hint"></div>';
                } else { if (hint) cell.innerHTML = ''; }
            } else {
                if (grid[r][c] === 1) b++; else w++;
            }
        }
    }
    document.getElementById('score').innerText = `黑 (玩家): ${b} | 白 (電腦): ${w}`;
}

async function handlePlayerMove(r, c) {
    if (isAnimating || turn !== 1) return;
    const flips = getFlips(r, c, 1);
    if (flips.length === 0) return;

    isAnimating = true;
    document.querySelectorAll('.hint').forEach(h => h.remove());

    // 1. 落下棋子
    await animateFlip(r, c, 1);
    
    // 2. 依序翻轉鄰近棋子
    for (let pos of flips) {
        await new Promise(res => setTimeout(res, 150)); // 間隔 150ms 翻下一顆
        animateFlip(pos.r, pos.c, 1);
    }
    
    // 等待最後一顆動畫完成
    await new Promise(res => setTimeout(res, 600));

    turn = 2;
    document.getElementById('status').innerText = "輪到：白棋 (電腦思考中...)";
    updateDisplay();
    setTimeout(aiMove, 600);
}

async function aiMove() {
    const moves = [];
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const f = getFlips(r, c, 2);
            if(f.length > 0) moves.push({r, c, f});
        }
    }

    if (moves.length > 0) {
        const weights = [
            [100,-20,10,5,5,10,-20,100], [-20,-50,1,1,1,1,-50,-20],
            [10,1,5,2,2,5,1,10], [5,1,2,1,1,2,1,5],
            [5,1,2,1,1,2,1,5], [10,1,5,2,2,5,1,10],
            [-20,-50,1,1,1,1,-50,-20], [100,-20,10,5,5,10,-20,100]
        ];
        const isPro = document.getElementById('level').value === "2";
        moves.sort((a, b) => isPro ? (weights[b.r][b.c] - weights[a.r][a.c]) : (b.f.length - a.f.length));
        
        const best = moves[0];
        await animateFlip(best.r, best.c, 2);
        for (let pos of best.f) {
            await new Promise(res => setTimeout(res, 150));
            animateFlip(pos.r, pos.c, 2);
        }
        await new Promise(res => setTimeout(res, 600));
    }

    turn = 1;
    isAnimating = false;
    document.getElementById('status').innerText = "輪到：黑棋 (玩家)";
    
    if (!hasPossibleMoves(1)) {
        if (!hasPossibleMoves(2)) {
            const finalB = grid.flat().filter(x=>x===1).length;
            const finalW = grid.flat().filter(x=>x===2).length;
            let msg = finalB > finalW ? "恭喜你贏了！" : (finalB < finalW ? "電腦贏了！" : "平手！");
            alert(`遊戲結束！\n黑: ${finalB} vs 白: ${finalW}\n${msg}`);
        } else {
            alert("玩家無處可走，換電腦！");
            turn = 2; aiMove();
        }
    }
    updateDisplay();
}

function getFlips(r, c, color) {
    if (grid[r][c] !== 0) return [];
    const opp = color === 1 ? 2 : 1;
    const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
    let res = [];
    for (let [dr, dc] of dirs) {
        let temp = [], cr = r + dr, cc = c + dc;
        while (cr>=0 && cr<8 && cc>=0 && cc<8 && grid[cr][cc] === opp) {
            temp.push({r: cr, c: cc});
            cr += dr; cc += dc;
        }
        if (cr>=0 && cr<8 && cc>=0 && cc<8 && grid[cr][cc] === color) res = res.concat(temp);
    }
    return res;
}

function hasPossibleMoves(color) {
    for(let r=0; r<8; r++)
        for(let c=0; c<8; c++)
            if(getFlips(r,c,color).length > 0) return true;
    return false;
}

createBoardDOM();
initGame();
</script>
</body>
</html>
